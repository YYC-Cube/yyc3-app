# 🚀 🚀 YYC³邮件平台 - 开发规范与最佳实践

> **YYC³ 项目文档**
> 
> @project YYC³ Email Platform
> @type 技术文档
> @version 1.0.0
> @created 2025-12-08
> @updated 2025-12-08
> @author YYC³ <admin@0379.email>
> @url https://github.com/YY-Nexus/0379-email-platform


## 1. 文档目的

本文档旨在为YYC³邮件平台项目团队提供统一的开发规范、编码标准和最佳实践指南，确保代码质量、可维护性和团队协作效率。通过遵循这些规范，我们可以减少代码缺陷，提高开发效率，并使项目更容易维护和扩展。

## 2. 技术栈规范

### 2.1 核心技术栈

| 类别 | 技术/框架 | 版本要求 | 用途 |
|------|-----------|----------|------|
| 前端框架 | Next.js | ^14.0.0 | 前端开发框架 |
| 前端语言 | TypeScript | ^5.0.0 | 类型安全的JavaScript超集 |
| 样式方案 | Tailwind CSS | ^3.3.0 | 实用优先的CSS框架 |
| 状态管理 | React Context + Zustand | - | 前端状态管理 |
| 后端框架 | Express.js | ^4.18.0 | 后端API开发框架 |
| 数据库 | PostgreSQL | ^14.0 | 关系型数据库 |
| 缓存 | Redis | ^7.0 | 高性能缓存 |
| 认证 | JWT | - | 用户身份验证 |
| API文档 | Swagger | - | API接口文档 |

### 2.2 开发工具

| 工具 | 用途 | 要求 |
|------|------|------|
| ESLint | 代码质量检查 | 必须配置项目级规则 |
| Prettier | 代码格式化 | 统一团队代码风格 |
| Jest | 单元测试框架 | 保持80%+的测试覆盖率 |
| Docker | 容器化部署 | 提供开发和生产环境配置 |
| Git | 版本控制 | 遵循分支管理规范 |

## 3. 代码规范

### 3.1 命名规范

#### 3.1.1 文件命名

- **组件文件**: 使用PascalCase命名，如 `Layout.tsx`, `EmailList.tsx`
- **服务文件**: 使用camelCase命名，如 `apiService.ts`, `authService.ts`
- **工具函数文件**: 使用camelCase命名，如 `dateUtils.ts`, `stringUtils.ts`
- **类型定义文件**: 使用PascalCase + Types后缀，如 `EmailTypes.ts`, `UserTypes.ts`
- **配置文件**: 使用kebab-case命名，如 `jest.config.js`, `next.config.js`

#### 3.1.2 变量与函数命名

- **变量**: 使用camelCase，如 `userName`, `emailList`
- **常量**: 使用全大写+下划线，如 `MAX_PAGE_SIZE`, `API_ENDPOINTS`
- **函数**: 使用camelCase，如 `fetchEmails()`, `validateUser()`
- **类**: 使用PascalCase，如 `UserService`, `MailModel`
- **接口**: 使用I前缀+PascalCase，如 `IUser`, `IEmailData`

#### 3.1.3 命名原则

- 命名应具描述性，清晰表达变量/函数/类的用途
- 避免使用单个字母或无意义的缩写
- 保持命名一致性，相似概念使用相似命名模式
- 布尔类型变量建议使用is/has/can等前缀，如 `isLoading`, `hasPermission`

### 3.2 代码格式规范

#### 3.2.1 缩进与换行

- 使用2个空格进行缩进
- 每行代码不超过100个字符
- 函数参数过多时，每个参数单独一行
- 大括号使用K&R风格，左大括号放在行尾，右大括号单独成行

```typescript
// 推荐
function sendEmail(
  recipient: string,
  subject: string,
  content: string,
  attachments?: File[]
): Promise<boolean> {
  // 函数体
}

// 不推荐
function sendEmail(recipient:string,subject:string,content:string,attachments?:File[])
{
  // 函数体
}
```

#### 3.2.2 空行使用

- 函数之间使用2个空行分隔
- 函数内部不同逻辑块之间使用1个空行分隔
- 文件末尾保留一个空行

#### 3.2.3 注释规范

- 文件头部必须包含标准化注释，说明文件目的、作者等信息
- 类和函数必须包含JSDoc格式的注释
- 复杂逻辑必须添加行内注释
- 避免冗余注释和注释与代码不一致

```typescript
/**
 * @description 发送邮件功能
 * @author YYC
 * @param recipient - 收件人邮箱
 * @param subject - 邮件主题
 * @param content - 邮件内容
 * @param attachments - 可选的附件列表
 * @returns Promise<boolean> 发送是否成功
 */
async function sendEmail(
  recipient: string,
  subject: string,
  content: string,
  attachments?: File[]
): Promise<boolean> {
  // 验证收件人邮箱格式
  if (!validateEmail(recipient)) {
    throw new Error('无效的收件人邮箱');
  }
  // 实现发送逻辑
  return true;
}
```

## 4. 前端开发规范

### 4.1 组件开发规范

#### 4.1.1 组件结构

- 遵循单一职责原则，每个组件只负责一个功能
- 组件大小控制在合理范围内，过大应考虑拆分
- 使用函数组件和React Hooks，避免使用class组件
- 组件命名应反映其功能和用途

```tsx
// 组件结构示例
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';

interface EmailCardProps {
  email: { id: string; subject: string; from: string; date: Date; isRead: boolean };
  onSelect: (id: string) => void;
}

/**
 * @description 邮件卡片组件 - 显示单封邮件的基本信息
 */
export const EmailCard: React.FC<EmailCardProps> = ({ email, onSelect }) => {
  const handleClick = () => {
    onSelect(email.id);
  };

  return (
    <div 
      className={`p-4 border-b cursor-pointer hover:bg-gray-50 ${email.isRead ? 'opacity-70' : ''}`}
      onClick={handleClick}
    >
      <h3 className="font-medium text-gray-900">{email.subject}</h3>
      <div className="flex justify-between mt-1 text-sm text-gray-600">
        <span>{email.from}</span>
        <span>{formatDate(email.date)}</span>
      </div>
    </div>
  );
};
```

#### 4.1.2 Props设计

- 使用TypeScript接口定义组件Props
- 为可选props提供默认值
- Props命名应清晰表达其用途
- 避免传递过多props，考虑使用context或状态管理

#### 4.1.3 状态管理

- 组件内部状态使用useState
- 共享状态使用React Context或Zustand
- 避免过度使用全局状态，优先使用局部状态
- 状态命名应清晰表达数据内容和用途

### 4.2 路由与页面设计

- 遵循Next.js的App Router规范
- 页面组件放在app目录下，按路由结构组织
- 动态路由使用`[param]`命名
- 布局组件放在components/layout目录下

### 4.3 性能优化规范

- 使用React.memo避免不必要的重渲染
- 使用useCallback和useMemo优化性能
- 大型列表使用虚拟滚动
- 实现懒加载和代码分割
- 避免在渲染期间执行昂贵的计算

```typescript
// 性能优化示例
import React, { useCallback, useMemo } from 'react';

// 使用memo包装组件
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  // 组件内容
});

const ParentComponent = () => {
  // 使用useCallback缓存回调函数
  const handleUpdate = useCallback((id, value) => {
    // 处理更新逻辑
  }, []);

  // 使用useMemo缓存计算结果
  const processedData = useMemo(() => {
    return rawData.map(item => ({
      ...item,
      processed: expensiveOperation(item)
    }));
  }, [rawData]);

  return (
    <ExpensiveComponent data={processedData} onUpdate={handleUpdate} />
  );
};
```

## 5. 后端开发规范

### 5.1 API设计规范

#### 5.1.1 RESTful API 设计

- 使用标准的HTTP方法：GET, POST, PUT, DELETE, PATCH
- 资源路径使用名词复数，如 `/api/v1/mails`, `/api/v1/users`
- 使用HTTP状态码表示操作结果
- 分页数据返回标准格式：`{ data: [...], total: 100, page: 1, pageSize: 20 }`

#### 5.1.2 API版本控制

- API路径中包含版本号，如 `/api/v1/`, `/api/v2/`
- 版本升级时保持向后兼容

#### 5.1.3 错误处理规范

- 统一错误响应格式：`{ error: string, code: string, details?: any }`
- 使用适当的HTTP状态码
- 提供有意义的错误信息，但避免暴露敏感信息
- 实现全局错误处理中间件

```typescript
// 错误响应格式示例
{
  "error": "邮件发送失败",
  "code": "EMAIL_SEND_FAILED",
  "details": { "recipient": "invalid@email" }
}
```

### 5.2 中间件使用规范

- 身份验证中间件：验证用户身份和权限
- 输入验证中间件：验证请求参数和数据格式
- 日志中间件：记录请求和响应信息
- 错误处理中间件：统一处理异常
- CORS中间件：处理跨域请求

### 5.3 安全性规范

- 输入验证：使用zod对所有用户输入进行验证
- 参数化查询：防止SQL注入
- 密码加密：使用bcrypt对密码进行哈希处理
- JWT安全：设置合理的过期时间，使用安全的签名算法
- HTTPS：强制使用HTTPS协议
- CORS配置：合理配置跨域资源共享策略

```typescript
// 输入验证示例
import { z } from 'zod';

const emailSchema = z.object({
  to: z.array(z.string().email()),
  subject: z.string().min(1).max(255),
  content: z.string().min(1),
  attachments: z.array(z.any()).optional()
});

// 使用验证模式
function validateEmailData(data: any) {
  try {
    return emailSchema.parse(data);
  } catch (error) {
    throw new Error('无效的邮件数据');
  }
}
```

## 6. 数据库规范

### 6.1 表结构设计规范

- 使用有意义的表名和字段名
- 遵循命名约定：表名使用snake_case，避免使用复数
- 每个表必须有主键
- 使用适当的数据类型和约束
- 外键关系必须明确定义

### 6.2 SQL查询规范

- 使用参数化查询防止SQL注入
- 避免SELECT *，只查询需要的字段
- 合理使用索引优化查询性能
- 大型查询使用分页
- 复杂查询考虑使用视图或存储过程

### 6.3 事务处理规范

- 多表操作使用事务确保数据一致性
- 事务范围应尽可能小
- 实现事务回滚机制
- 避免长时间运行的事务

### 6.4 索引优化规范

- 为频繁查询的字段创建索引
- 为外键创建索引
- 避免在经常更新的列上创建过多索引
- 考虑复合索引的顺序，将选择性高的列放在前面
- 定期检查和优化索引

```sql
-- 索引创建示例
CREATE INDEX CONCURRENTLY idx_emails_user_id ON emails(user_id);
CREATE INDEX CONCURRENTLY idx_emails_created_at ON emails(created_at DESC);
CREATE INDEX CONCURRENTLY idx_emails_user_id_created_at ON emails(user_id, created_at DESC);
```

## 7. 缓存策略规范

### 7.1 Redis缓存使用规范

- 为频繁访问的数据设置合理的缓存
- 设置适当的缓存过期时间
- 实现缓存穿透、缓存击穿和缓存雪崩的防护
- 使用缓存预热减少冷启动问题
- 缓存键使用统一的命名规范：`{service}:{entity}:{id}`

```typescript
// 缓存键命名示例
const CACHE_KEYS = {
  USER_INFO: (id: string) => `user:info:${id}`,
  EMAIL_LIST: (userId: string, page: number) => `email:list:${userId}:${page}`,
  CATEGORIES: (userId: string) => `category:list:${userId}`
};

// 缓存使用示例
async function getUserWithCache(id: string) {
  const cacheKey = CACHE_KEYS.USER_INFO(id);
  
  // 尝试从缓存获取
  const cachedUser = await redisService.get(cacheKey);
  if (cachedUser) return cachedUser;
  
  // 从数据库获取
  const user = await userModel.getUserById(id);
  
  // 设置缓存，过期时间1小时
  await redisService.set(cacheKey, user, 3600);
  
  return user;
}
```

### 7.2 缓存更新策略

- 数据更新时同步更新或失效相关缓存
- 考虑使用发布/订阅模式实现缓存一致性
- 重要数据考虑使用缓存预热

## 8. 测试规范

### 8.1 测试类型与覆盖范围

- **单元测试**：测试单个函数、组件或模块
- **集成测试**：测试多个组件或服务的协作
- **端到端测试**：测试完整的用户流程
- **性能测试**：测试系统在不同负载下的性能

### 8.2 测试编写规范

- 测试文件与被测试文件放在同一目录下，使用.test.ts/.spec.ts后缀
- 测试函数命名清晰表达测试目的：`it('should do something when condition')`
- 每个测试应独立运行，不依赖其他测试的状态
- 使用mock隔离外部依赖
- 测试覆盖率目标：核心功能 > 90%，一般功能 > 80%

### 8.3 测试工具使用

- **前端测试**：Jest + React Testing Library
- **后端测试**：Jest + Supertest
- **API测试**：Postman或自动化测试脚本
- **性能测试**：k6或JMeter

## 9. 版本控制规范

### 9.1 Git分支管理

- **main/master**：稳定版本分支，只接受合并请求
- **develop**：开发主分支，包含最新的开发功能
- **feature/***：新功能分支，从develop分支创建
- **bugfix/***：bug修复分支，从main或develop分支创建
- **hotfix/***：紧急修复分支，从main分支创建

### 9.2 提交规范

- 提交消息使用语义化提交格式：`type(scope): description`
- **type**：feat, fix, docs, style, refactor, test, chore
- **scope**：影响的模块或功能
- **description**：简洁明了的描述

**提交示例**：
- `feat(auth): 添加用户注册功能`
- `fix(email): 修复邮件发送失败问题`
- `docs: 更新API文档`
- `refactor(frontend): 重构布局组件`

### 9.3 代码审查流程

- 所有代码变更必须通过Pull Request进行
- 至少需要一名团队成员的批准
- 必须通过自动化测试和代码质量检查
- 详细描述PR的目的和变更内容
- 解决所有代码审查中的评论

## 10. 文档规范

### 10.1 技术文档

- **架构文档**：描述系统整体架构和组件关系
- **API文档**：使用Swagger自动生成并手动补充
- **数据库文档**：描述数据库结构和关系
- **开发指南**：新成员入职和开发流程指南

### 10.2 注释文档

- 文件头部必须包含标准化注释
- 类和函数必须包含JSDoc注释
- 复杂逻辑必须包含行内注释
- 避免冗余注释

### 10.3 文档更新规范

- 代码变更时同步更新相关文档
- 文档使用Markdown格式
- 文档存放于项目根目录的docs文件夹
- 重要更新在团队会议中进行同步

## 11. 部署与运维规范

### 11.1 Docker容器化规范

- 使用Docker进行环境一致性管理
- 提供开发和生产环境的Docker配置
- 优化Docker镜像大小
- 使用多阶段构建减小镜像体积

### 11.2 CI/CD流程规范

- 自动化构建、测试和部署流程
- 开发分支自动部署到测试环境
- 主分支自动部署到预发布环境
- 生产环境部署需要手动确认
- 实现部署回滚机制

### 11.3 监控与日志规范

- 使用结构化日志格式
- 关键操作必须记录日志
- 实现性能监控和告警机制
- 日志级别合理设置：debug, info, warn, error
- 定期清理和归档日志

## 12. 团队协作规范

### 12.1 沟通规范

- 日常沟通使用即时通讯工具
- 重要决策和讨论使用邮件或项目管理工具记录
- 代码相关讨论在PR评论中进行
- 定期举行团队会议同步进度和讨论问题

### 12.2 任务管理规范

- 使用项目管理工具跟踪任务进度
- 任务状态及时更新
- 任务分解粒度合理，避免过大或过小
- 定期进行任务优先级评估和调整

### 12.3 知识共享规范

- 定期举行技术分享会议
- 重要技术决策和学习心得记录到团队知识库
- 代码中包含清晰的注释和文档
- 新成员入职提供导师指导

## 13. 安全规范

### 13.1 数据安全

- 敏感数据加密存储
- 数据传输使用HTTPS
- 实现数据访问权限控制
- 定期进行数据备份
- 制定数据泄露应急响应预案

### 13.2 应用安全

- 定期进行安全漏洞扫描
- 使用安全的第三方依赖
- 实现防XSS、CSRF等常见攻击的措施
- 避免硬编码敏感信息
- 实现安全的密码策略

### 13.3 环境安全

- 最小权限原则配置服务器访问权限
- 定期更新系统和软件补丁
- 使用防火墙和入侵检测系统
- 监控异常访问行为

## 14. 最佳实践

### 14.1 代码可维护性

- 遵循单一职责原则
- 保持代码简洁，避免过度设计
- 代码重用通过抽象和组合实现
- 避免魔法数字和硬编码字符串
- 使用配置文件管理可配置项

### 14.2 性能优化

- 前端优化：减少DOM操作，优化渲染性能，使用CDN加速
- 后端优化：优化数据库查询，使用缓存，实现异步处理
- 网络优化：压缩传输数据，减少HTTP请求，使用HTTP/2
- 资源优化：优化图片大小，使用适当的图片格式

### 14.3 错误处理

- 捕获所有可能的异常
- 提供有意义的错误信息
- 实现详细的错误日志记录
- 用户界面友好显示错误
- 实现优雅降级机制

## 15. 规范执行与更新

### 15.1 规范执行

- 团队成员必须熟悉并遵守本规范
- 通过代码审查确保规范执行
- 定期进行规范执行情况检查
- 对违反规范的情况进行及时纠正

### 15.2 规范更新

- 规范应根据项目进展和团队反馈定期更新
- 重大规范变更应在团队会议中讨论
- 规范更新后及时通知所有团队成员
- 保留规范版本历史

## 16. 附录

### 16.1 常用工具与资源

- **代码质量工具**：ESLint, Prettier, SonarQube
- **测试工具**：Jest, React Testing Library, Supertest
- **监控工具**：Prometheus, Grafana, ELK Stack
- **文档工具**：Swagger, Markdown

### 16.2 参考资料

- React官方文档
- Next.js官方文档
- TypeScript官方文档
- Express.js官方文档
- PostgreSQL官方文档
- Redis官方文档
- RESTful API设计指南
- 安全编码实践指南

---

**文档版本**：v1.0.0  
**创建日期**：2024-05-15  
**最后更新**：2024-05-15  
**责任人**：技术团队  

*本规范将根据项目发展和团队反馈持续更新和完善。*